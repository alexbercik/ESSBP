# Add the root folder of ECO to the search path
import os
import sys

test_folder_path, _ = os.path.split(__file__)
root_folder_path, _ = os.path.split(test_folder_path)
sys.path.append(root_folder_path)

# Import the required modules
import numpy as np
import sys

##### Functions to build operators
def tridiag(nn, a, b, c, bc='SAT', k1=-1, k2=0, k3=1): 
    """ Builds a tri-diagonal matrix 
    INPUT: (a,b,c) arrays on three diagonal bands,
            bc is a string that determines what we do to with BC corner values
           (k1,k2,k3) indicate which band to appy them to
    OUTPUT: 2D array (matrix) """ 
    a = np.ones(nn)*a
    b = np.ones(nn)*b
    c = np.ones(nn)*c
    if bc == 'periodic':
        A = (np.diag(a[:-1], k1) + np.diag(b, k2) + np.diag(c[1:], k3) + 
            np.diag(a[-1:], len(c)-1) + np.diag(c[:1], -(len(c)-1)))
            #np.diag(array, which diagonal - 0 is main, 1 is one above, etc)
    else:
        A = np.diag(a[:-1], k1) + np.diag(b, k2) + np.diag(c[1:], k3)
    return A
    
def pentadiag(nn, a, b, c, d, e, bc='SAT', k1=-2, k2=-1, k3=0, k4=1, k5=2): 
    """ Builds a penta-diagonal matrix 
    INPUT:  nn number of nodes (makes matrix size nn x nn) 
            (a,b,c,d,e) arrays on three diagonal bands,
            bc is a string that determines what we do to with BC corner values
           (k1,k2,k3,k4,k5) indicate which band to appy them to
    OUTPUT: 2D array (matrix) """ 
    a = np.ones(nn)*a
    b = np.ones(nn)*b
    c = np.ones(nn)*c
    d = np.ones(nn)*d
    e = np.ones(nn)*e
    if bc == 'periodic':
        A = (np.diag(a[:-2], k1) + np.diag(b[:-1], k2) + np.diag(c, k3) +
            np.diag(d[1:], k4) + np.diag(e[2:], k5) + np.diag(a[-2:], len(c)-2) +
            np.diag(b[-1:], len(c)-1) + np.diag(d[:1], -(len(c)-1)) +
            np.diag(e[:2], -(len(c)-2)))
            #np.diag(array, which diagonal - 0 is main, 1 is one above, etc)
    else:
        A = (np.diag(a[:-2], k1) + np.diag(b[:-1], k2) + np.diag(c, k3) +
            np.diag(d[1:], k4) + np.diag(e[2:], k5))
    return A

def heptadiag(nn, a, b, c, d, e, f, g, bc='SAT', k1=-3, k2=-2, k3=-1, k4=0, 
              k5=1, k6=2, k7=3): 
    """ Builds a hepta-diagonal matrix 
    INPUT: nn number of nodes (makes matrix size nn x nn) 
            (a,b,c,d,e,f,g) arrays on three diagonal bands,
            bc is a string that determines what we do to with BC corner values
            (k1,k2,k3,k4,k5,k6,k7) indicate which band to appy them to
    OUTPUT: 2D array (matrix) """ 
    a = np.ones(nn)*a
    b = np.ones(nn)*b
    c = np.ones(nn)*c
    d = np.ones(nn)*d
    e = np.ones(nn)*e
    f = np.ones(nn)*f
    g = np.ones(nn)*g
    if bc == 'periodic':
        A = (np.diag(a[:-3], k1) + np.diag(b[:-2], k2) + np.diag(c[:-1], k3) +
            np.diag(d, k4) + np.diag(e[1:], k5) + np.diag(f[2:], k6) + 
            np.diag(g[3:], k7) + np.diag(a[-3:], len(d)-3) +
            np.diag(b[-2:], len(d)-2) + np.diag(c[-1:], len(d)-1) +
            np.diag(e[:1], -(len(d)-1)) + np.diag(f[:2], -(len(d)-2)) + 
            np.diag(g[:3], -(len(d)-3)))
            #np.diag(array, which diagonal - 0 is main, 1 is one above, etc)
    else:
        A = (np.diag(a[:-3], k1) + np.diag(b[:-2], k2) + np.diag(c[:-1], k3) +
            np.diag(d, k4) + np.diag(e[1:], k5) + np.diag(f[2:], k6) + 
            np.diag(g[3:], k7))
    return A

def nonadiag(nn, a, b, c, d, e, f, g, h, i, bc='SAT', k1=-4, k2=-3, k3=-2, 
             k4=-1, k5=0, k6=1, k7=2, k8=3, k9=4): 
    """ Builds a nona-diagonal matrix 
    INPUT: nn number of nodes (makes matrix size nn x nn) 
            (a,b,c,d,e,f,g) arrays on three diagonal bands,
            bc is a string that determines what we do to with BC corner values
           (k1,k2,k3,k4,k5,k6,k7) indicate which band to appy them to
    OUTPUT: 2D array (matrix) """ 
    a = np.ones(nn)*a
    b = np.ones(nn)*b
    c = np.ones(nn)*c
    d = np.ones(nn)*d
    e = np.ones(nn)*e
    f = np.ones(nn)*f
    g = np.ones(nn)*g
    h = np.ones(nn)*h
    i = np.ones(nn)*i
    if bc == 'periodic':
        A = (np.diag(a[:-4], k1) + np.diag(b[:-3], k2) + np.diag(c[:-2], k3) +
            np.diag(d[:-1], k4) + np.diag(e, k5) + np.diag(f[1:], k6) + 
            np.diag(g[2:], k7) + np.diag(h[3:], k8) + np.diag(i[4:], k9) +
            np.diag(a[-4:], len(e)-4) + np.diag(b[-3:], len(e)-3) + 
            np.diag(c[-2:], len(e)-2) + np.diag(d[-1:], len(e)-1) + 
            np.diag(f[:1], -(len(e)-1)) + np.diag(g[:2], -(len(e)-2)) + 
            np.diag(h[:3], -(len(e)-3)) + np.diag(i[:4], -(len(e)-4)))
            #np.diag(array, which diagonal - 0 is main, 1 is one above, etc)
    else:
        A = (np.diag(a[:-4], k1) + np.diag(b[:-3], k2) + np.diag(c[:-2], k3) +
            np.diag(d[:-1], k4) + np.diag(e, k5) + np.diag(f[1:], k6) + 
            np.diag(g[2:], k7) + np.diag(h[3:], k8) + np.diag(i[4:], k9))
    return A

        
def CSbpOp(p,nn):
    """ Builds a 1D CSBP first derivative operator on reference element [0,1] 
    for p=1,2,3,4
    INPUT: derivative order, grid size
    OUTPUT: 2D arrays (matrix) H and D """ 
    
    dx = 1/(nn-1)
    E = np.zeros((nn,nn))
    E[0,0] = -1
    E[-1,-1] = 1
    
    if p==1:
        if nn < 3:
            print ( '' )
            print ( 'CSBP_SET - Fatal error!' )
            print ( '  Illegal value of nn: %d' % ( nn ) )
            print ( '  nn must be at least 3 when p=1' )
            sys.exit ( 'CSBP_SET - Fatal error!' )
      
        H = dx*np.diag(np.ones(nn))
        H[0,0] = dx*0.5
        H[-1,-1] = dx*0.5
        
        Q = tridiag(nn, -1/2, 0, 1/2)
        Q[0,0] = -1/2
        Q[-1,-1] = 1/2

    elif p==2:
        if nn < 9:
            print ( '' )
            print ( 'CSBP_SET - Fatal error!' )
            print ( '  Illegal value of nn: %d' % ( nn ) )
            print ( '  nn must be at least 9 when p=2' )
            sys.exit ( 'CSBP_SET - Fatal error!' )
                
        H = dx*np.diag(np.ones(nn))
        H[0,0] = dx*17/48
        H[1,1] = dx*59/48
        H[2,2] = dx*43/48
        H[3,3] = dx*49/48
                    
        Q = pentadiag(nn, 1/12, -2/3, 0, 2/3, -1/12)
        Q[0,0] = -1/2
        Q[0,1] = 59/96
        Q[0,2] = -1/12
        Q[0,3] = -1/32
        Q[1,0] = - Q[0,1]
        Q[1,1] = 0
        Q[1,2] = 59/96
        Q[1,3] = 0
        Q[2,0] = -Q[0,2]
        Q[2,1] = -Q[1,2]
        Q[2,3] = 59/96
        Q[3,0] = -Q[0,3]
        Q[3,1] = -Q[1,3]
        Q[3,2] = -Q[2,3]
        
        #bottom portion of the matrices
        for i in range(4):
            for j in range(4):
                Q[-1-i,-1-j] = -Q[i,j]
                if i == j:
                    H[-1-i,-1-i] = H[i,j]
  
    elif p==3:
        if nn < 13:
                print ( '' )
                print ( 'CSBP_SET - Fatal error!' )
                print ( '  Illegal value of nn: %d' % ( nn ) )
                print ( '  nn must be at least 13 when p=3' )
                sys.exit ( 'CSBP_SET - Fatal error!' )
                
        H = dx*np.diag(np.ones(nn))
        H[0,0] = dx*13649/43200
        H[1,1] = dx*12013/8640
        H[2,2] = dx*2711/4320
        H[3,3] = dx*5359/4320
        H[4,4] = dx*7877/8640
        H[5,5] = dx*43801/43200

        Q = heptadiag(nn,-1/60,3/20,-3/4,0,3/4,-3/20,1/60)
        q = 5591070156686698065364559/7931626489314500743872000
        Q[0,0] = -1/2
        Q[0,1] = -0.953E3 / 0.16200E5 + q
        Q[0,2] = 0.715489E6 / 0.259200E6 - (4 * q)
        Q[0,3] = -0.62639E5 / 0.14400E5 + (6* q)
        Q[0,4] = 0.147127E6 / 0.51840E5 - (4* q)
        Q[0,5] = -0.89387E5 / 0.129600E6 + q
        Q[1,0] = - Q[0,1]
        Q[1,2] = -0.57139E5 / 0.8640E4 + (10* q)
        Q[1,3] = 0.745733E6 / 0.51840E5 - (20 * q)
        Q[1,4] = -0.18343E5 / 0.1728E4 + (15 * q)
        Q[1,5] = 0.240569E6 / 0.86400E5 - (4 * q)
        Q[2,0] = -Q[0,2]
        Q[2,1] = -Q[1,2]
        Q[2,3] = -0.176839E6 / 0.12960E5 + (20 * q)
        Q[2,4] = 0.242111E6 / 0.17280E5 - (20 * q)
        Q[2,5] = -0.182261E6 / 0.43200E5 + (6 * q)
        Q[3,0] = -Q[0,3]
        Q[3,1] = -Q[1,3]
        Q[3,2] = -Q[2,3]
        Q[3,4] = -0.165041E6 / 0.25920E5 + (10 * q)
        Q[3,5] = 0.710473E6 / 0.259200E6 - (4 * q)
        Q[3,6] = 1/60
        Q[4,0] = -Q[0,4]
        Q[4,1] = -Q[1,4]
        Q[4,2] = -Q[2,4]
        Q[4,3] = -Q[3,4]
        Q[4,5] = q
        Q[4,6] = -3/20
        Q[4,7] = 1/60
        Q[5,0] = -Q[0,5]
        Q[5,1] = -Q[1,5]
        Q[5,2] = -Q[2,5]
        Q[5,3] = -Q[3,5]
        Q[5,4] = -Q[4,5]
        Q[5,6] = 3/4
        Q[5,7] = -3/20
        Q[5,8] = 1/60
        
        #bottom portion of the matrices
        for i in range(6):
            for j in range(6):
                Q[-1-i,-1-j] = -Q[i,j]
                if i == j:
                    H[-1-i,-1-i] = H[i,j]
        
    elif p==4:
        if nn < 17:
            print ( '' )
            print ( 'CSBP_SET - Fatal error!' )
            print ( '  Illegal value of nn: %d' % ( nn ) )
            print ( '  nn must be at least 17 when p=4' )
            sys.exit ( 'CSBP_SET - Fatal error!' )
                
        H = dx*np.diag(np.ones(nn))
        H[0,0] = dx*0.1498139E7 / 0.5080320E7
        H[1,1] = dx*0.1107307E7 / 0.725760E6
        H[2,2] = dx*0.20761E5 / 0.80640E5
        H[3,3] = dx*0.1304999E7 / 0.725760E6
        H[4,4] = dx*0.299527E6 / 0.725760E6
        H[5,5] = dx*0.103097E6 / 0.80640E5
        H[6,6] = dx*0.670091E6 / 0.725760E6
        H[7,7] = dx*0.5127739E7 / 0.5080320E7

        Q = nonadiag(nn,1/280,-4/105,1/5,-4/5,0,4/5,-1/5,4/105,-1/280)
        q16 = 0.08314829949122060462305047907908720666335
        q17 = -0.9521334029619388274601963790830716099197E-2
        q47 = -0.3510216710115618609017136924794334791187E-1
        Q[0,0] = -1/2
        Q[0,1] =  0.59065123E8/0.91445760E8 + q16/0.3E1 + 0.2E1/0.3E1*q17
        Q[0,2] = 0.771343E6 / 0.10160640E8 - 0.8E1 / 0.5E1 * q16 - 0.3E1 *q17
        Q[0,3] = -0.8276887E7 / 0.20321280E8 + (3 * q16) + (5 * q17)
        Q[0,4] = 0.17658817E8 / 0.91445760E8 - 0.8E1 / 0.3E1 * q16 - 0.10E2/ 0.3E1 * q17
        Q[0,5] = q16
        Q[0,6] = q17
        Q[0,7] = -0.1394311E7 / 0.182891520E9 - q16 / 0.15E2 - q17 / 0.3E1
        Q[1,0] = - Q[0,1]
        Q[1,2] = q47 / 0.45E2 + 0.14E2 / 0.3E1 * q16 + 0.77E2 / 0.9E1 * q17- 0.14866699E8 /0.130636800E9
        Q[1,3] = 0.18734719E8 / 0.13063680E8 - 0.35E2 / 0.3E1 * q16 - 0.175E3 / 0.9E1 * q17 -q47 / 0.9E1
        Q[1,4] = -0.2642179E7 / 0.3265920E7 + 0.35E2 / 0.3E1 * q16 + 0.140E3 / 0.9E1 * q17 +0.2E1 / 0.9E1 * q47
        Q[1,5] = 0.1736509E7 / 0.13063680E8 - 0.14E2 / 0.3E1 * q16 - 0.14E2 / 0.9E1 * q17 -0.2E1 / 0.9E1 * q47
        Q[1,6] = -0.13219E5 / 0.1244160E7 - 0.35E2 / 0.9E1 * q17 + q47 / 0.9E1
        Q[1,7] = 0.1407281E7 / 0.11430720E9 + q16 / 0.3E1 + 0.13E2 / 0.9E1 * q17 - q47 /0.45E2
        Q[2,0] = -Q[0,2]
        Q[2,1] = -Q[1,2]
        Q[2,3] = -0.3056891E7 / 0.4354560E7 + (14E0 * q16) + 0.7E2 / 0.3E1 * q17 + q47 /0.3E1
        Q[2,4] = 0.765701E6 / 0.653184E6 - 0.56E2 / 0.3E1 * q16 - 0.245E3 / 0.9E1 * q17 -0.8E1 / 0.9E1 * q47
        Q[2,5] = -0.238939E6 / 0.414720E6 + 0.42E2 / 0.5E1 * q16 + 0.7E1 * q17 + q47
        Q[2,6] = 0.754291E6 / 0.21772800E8 + 0.14E2 / 0.3E1 * q17 - 0.8E1 / 0.15E2 * q47
        Q[2,7] = 0.762499E6 / 0.22861440E8 - 0.2E1 / 0.3E1 * q16 - 0.20E2 / 0.9E1 * q17 + q47/ 0.9E1
        Q[3,0] = -Q[0,3]
        Q[3,1] = -Q[1,3]
        Q[3,2] = -Q[2,3]
        Q[3,4] = -0.10064459E8 / 0.26127360E8 + 0.35E2 / 0.3E1 * q16 + 0.175E3 / 0.9E1 * q17+ 0.10E2 / 0.9E1 * q47
        Q[3,5] = 0.62249E5 / 0.77760E5 - (7E0 * q16) - 0.35E2 / 0.3E1 * q17 - 0.5E1 / 0.3E1* q47
        Q[3,6] = q47
        Q[3,7] = -0.8276887E7 / 0.91445760E8 + 0.2E1 / 0.3E1 * q16 + 0.10E2 / 0.9E1 * q17 -0.2E1 / 0.9E1 * q47
        Q[4,0] = -Q[0,4]
        Q[4,1] = -Q[1,4]
        Q[4,2] = -Q[2,4]
        Q[4,3] = -Q[3,4]
        Q[4,5] = 0.792095E6 / 0.2612736E7 + 0.7E1 / 0.3E1 * q16 + 0.70E2 / 0.9E1 * q17 +0.10E2 / 0.9E1 * q47
        Q[4,6] = -0.42403E5 / 0.207360E6 - 0.35E2 / 0.9E1 * q17 - 0.8E1 / 0.9E1 * q47
        Q[4,7] = 0.13906657E8 / 0.182891520E9 - q16 / 0.3E1 + 0.5E1 / 0.9E1 * q17 + 0.2E1 /0.9E1 * q47
        Q[5,0] = -Q[0,5]
        Q[5,1] = -Q[1,5]
        Q[5,2] = -Q[2,5]
        Q[5,3] = -Q[3,5]
        Q[5,4] = -Q[4,5]
        Q[5,6] = 0.1360207E7 / 0.1741824E7 + 0.7E1 / 0.3E1 * q17 + q47 / 0.3E1
        Q[5,7] = -0.289189E6 / 0.1866240E7 + q16 / 0.15E2 - 0.7E1 / 0.9E1 * q17 - q47 / 0.9E1
        Q[6,0] = -Q[0,6]
        Q[6,1] = -Q[1,6]
        Q[6,2] = -Q[2,6]
        Q[6,3] = -Q[3,6]
        Q[6,4] = -Q[4,6]
        Q[6,5] = -Q[5,6]
        Q[6,7] = 0.16676111E8 / 0.21772800E8 + 0.2E1 / 0.9E1 * q17 + q47 / 0.45E2
        Q[7,0] = -Q[0,7]
        Q[7,1] = -Q[1,7]
        Q[7,2] = -Q[2,7]
        Q[7,3] = -Q[3,7]
        Q[7,4] = -Q[4,7]
        Q[7,5] = -Q[5,7]
        Q[7,6] = -Q[6,7]
        
        #bottom portion of the matrices
        for i in range(8):
            for j in range(8):
                Q[-1-i,-1-j] = -Q[i,j]
                if i == j:
                    H[-1-i,-1-i] = H[i,j]
        
    else:
        print("ERROR: You have not coded this order p yet")
        sys.exit()
     
    D = np.linalg.inv(H)@Q
    S = Q - E/2
    
    return H, D, Q, S, dx
        
        
def HGTLOp(p,nn):
    """ Builds a 1D HGTL first derivative operator on reference element [0,1] 
    for p=2,3,4
    INPUT: derivative order, grid size
    OUTPUT: 2D arrays (matrix) H and D """ 
    
    dx = 1/(nn-1)
    E = np.zeros((nn,nn))
    E[0,0] = -1
    E[-1,-1] = 1

    if p==2:
        if nn < 9:
            print ( '' )
            print ( 'HGTL_SET - Fatal error!' )
            print ( '  Illegal value of nn: %d' % ( nn ) )
            print ( '  nn must be at least 9 when p=2' )
            sys.exit ( 'HGTL_SET - Fatal error!' )
                
        H = np.diag(np.ones(nn))
        H[0,0] = 0.3200231481481481
        H[1,1] = 1.190687463256908
        H[2,2] = 0.9836309523809522
        H[3,3] = 1.005658436213992
                    
        D = pentadiag(nn, 1/12, -2/3, 0, 2/3, -1/12)
        D[0,0] = -1.562386980108499
        D[0,1] = 1.955715338174651
        D[0,2] = -0.3747093774218549
        D[0,3] = -0.01861898064429710
        D[1,0] = -0.5256410256410258
        D[1,1] = 0.0
        D[1,2] = 0.5769230769230770
        D[1,3] = -0.05128205128205128
        D[2,0] = 0.1219112455874937
        D[2,1] = -0.6983666722698495
        D[2,3] = 0.6611755477111001
        D[2,4] = -0.08472012102874434
        D[3,0] = 0.005924978687127025
        D[3,1] = 0.06071733041042503
        D[3,2] = -0.6466934599926927
        D[3,4] = 0.6629156010230178
        D[3,5] = -0.08286445012787723
        
        #bottom portion of the matrices
        for i in range(4):
            for j in range(6):
                D[-1-i,-1-j] = -D[i,j]
                if i == j:
                    H[-1-i,-1-i] = H[i,j]

        x = np.linspace(0, nn-1, nn, endpoint=True, dtype=np.float64)
        x[1] = 0.9230769230769231
        x[-2] = nn - 1.9230769230769231
        x = x / (nn-1)
  
    elif p==3:
        if nn < 13:
                print ( '' )
                print ( 'HGTL_SET - Fatal error!' )
                print ( '  Illegal value of nn: %d' % ( nn ) )
                print ( '  nn must be at least 13 when p=3' )
                sys.exit ( 'HGTL_SET - Fatal error!' )
                
        H = np.diag(np.ones(nn))
        H[0,0] = 0.23964384800553829484
        H[1,1] = 1.1413495975137771621
        H[2,2] = 1.1140964967090706556
        H[3,3] = 1.0084546102281871184
        H[4,4] = 0.99554237603482965904
        H[5,5] = 1.0009130715085971099

        D = heptadiag(nn,-1/60,3/20,-3/4,0,3/4,-3/20,1/60)
        D[0,0] = -2.0864295251528624183
        D[0,1] = 2.7374848692200391159
        D[0,2] = -0.72250333379125646597
        D[0,3] = -0.027920696644146505545
        D[0,4] = 0.12300916308384004575
        D[0,5] = -0.023640476715613771855
        D[1,0] = -0.57477692141465808502
        D[1,2] = 0.67091771498298926960
        D[1,3] = -0.054319800816258615611
        D[1,4] = -0.056501441643580342822
        D[1,5] = 0.014680448891507773851
        D[2,0] = 0.15541156409522428396
        D[2,1] = -0.68732974766786494723
        D[2,3] = 0.58461354292529653895
        D[2,4] = -0.043595016069415794311
        D[2,5] = -0.0091003432832400813799
        D[3,0] = 0.0066349274572551989597
        D[3,1] = 0.061478109346574163082
        D[3,2] = -0.64585544405848358341
        D[3,4] = 0.68657904802890928860
        D[3,5] = -0.12536357862314390551
        D[3,6] = 0.016526937848888838281
        D[4,0] = -0.029610381125876772034
        D[4,1] = 0.064776647615643478857
        D[4,2] = 0.048786526667361628961
        D[4,3] = -0.69548401247222248717
        D[4,5] = 0.74546156376149528088
        D[4,6] = -0.15067163750220127068
        D[4,7] = 0.016741293055800141186
        D[5,0] = 0.0056601267083825402592
        D[5,1] = -0.016740239398002562802
        D[5,2] = 0.010129411693491519063
        D[5,3] = 0.12630815044373950202
        D[5,4] = -0.74146156899638836890
        D[5,6] = 0.74931582107283734232
        D[5,7] = -0.14986316421456746846
        D[5,8] = 0.016651462690507496496
        
        #bottom portion of the matrices
        for i in range(6):
            for j in range(9):
                D[-1-i,-1-j] = -D[i,j]
                if i == j:
                    H[-1-i,-1-i] = H[i,j]

        x = np.linspace(0, nn-1, nn, endpoint=True, dtype=np.float64)
        x[1] = 0.4530911073 / 0.5832340780
        x[2] = 0.3476591521 / 0.1773010470
        x[-3] = nn - 1.0 - 0.3476591521 / 0.1773010470
        x[-2] = nn - 1.0 - 0.4530911073 / 0.5832340780
        x = x / (nn-1)
        
    elif p==4:
        if nn < 17:
            print ( '' )
            print ( 'HGTL_SET - Fatal error!' )
            print ( '  Illegal value of nn: %d' % ( nn ) )
            print ( '  nn must be at least 17 when p=4' )
            sys.exit ( 'HGTL_SET - Fatal error!' )
                
        H = np.diag(np.ones(nn))
        H[0,0] = 0.190353545114720981146105850455
        H[1,1] = 1.00814468361001322878579338853
        H[2,2] = 1.23748445746070721453213596744
        H[3,3] = 1.06592880631025143507305283893
        H[4,4] = 0.996519952430389714672623705058
        H[5,5] = 1.00222268372255478207271906866
        H[6,6] = 0.999234151363896630994667331876
        H[7,7] = 1.00011171998746601272290184905

        D = nonadiag(nn,1/280,-4/105,1/5,-4/5,0,4/5,-1/5,4/105,-1/280)
        D[0,0] = -2.62669129539280919314952176709
        D[0,1] = 3.48988804946919111883611187585
        D[0,2] = -1.07609329056030747032533414098
        D[0,3] = -0.0141959344958947354681559533109
        D[0,4] = 0.457041690997071134103762860621
        D[0,5] = -0.298091146776722451000371965430
        D[0,6] = 0.0741178487000497778459520560891
        D[0,7] = -0.00597592194057818084244296574816
        D[1,0] = -0.658945658366373301820700709116
        D[1,2] = 0.820352543006715127845918969775
        D[1,3] = -0.0616561113362300703078556653695
        D[1,4] = -0.226274110826258495913078245350
        D[1,5] = 0.171372325183229993101185636145
        D[1,6] = -0.0501374210247507919792667042525
        D[1,7] = 0.00528843336366753907379671816872
        D[2,0] = 0.165527875115816630488958579266
        D[2,1] = -0.668318741243208460951125523194
        D[2,3] = 0.474015974639523655037337620036
        D[2,4] = 0.192508555600526307627188266873
        D[2,5] = -0.245836658226132689158450929215
        D[2,6] = 0.0958430976294098250570674342460
        D[2,7] = -0.0137401035159352681009754480124
        D[3,0] = 0.00253510970105390036155568852652
        D[3,1] = 0.0583137264775218926507388896451
        D[3,2] = -0.550306359798072613918331263801
        D[3,4] = 0.387071131720088245391974351063
        D[3,5] = 0.225901393889571396731514059015
        D[3,6] = -0.152485287419153885302338607929
        D[3,7] = 0.0289702854289910640848868834812
        D[4,0] = -0.0873033258735444693805740289786
        D[4,1] = 0.228913672337142879656324289805
        D[4,2] = -0.239058279669019072842097927455
        D[4,3] = -0.414031117375316765603565262007
        D[4,5] = 0.540370174358853529869085398556
        D[4,6] = -0.0263191642950773920863965462954
        D[4,7] = 0.00101194123336771655963477701369
        D[4,8] = -0.00358390071640642617241070063883
        D[5,0] = 0.0566168651716227063107497888712
        D[5,1] = -0.172384941348211473270120189642
        D[5,2] = 0.303544360519718637050362555589
        D[5,3] = -0.240260779408972118926334558585
        D[5,4] = -0.537295422656743779260144180490
        D[5,6] = 0.735229145300304861344975710002
        D[5,7] = -0.179896471772569592566525738941
        D[5,8] = 0.0380107522150077344187990214584
        D[5,9] = -0.00356350802015697510176240826173
        D[6,0] = -0.0141194085861392701705353490929
        D[6,1] = 0.0505845145374858970323021274415
        D[6,2] = -0.118695246263746855167009996088
        D[6,3] = 0.162663035662580923012231535745
        D[6,4] = 0.0262476740967460128715611305660
        D[6,5] = -0.737428085447375905205555836250
        D[6,7] = 0.796350533321589671842805716142
        D[6,8] = -0.200153287121953954447872569653
        D[6,9] = 0.0381244356422769437043566799339
        D[6,10] = -0.00357416584146346347228343874380
        D[7,0] = 0.00113741085519141400970041354164
        D[7,1] = -0.00533091041096295399037881006661
        D[7,2] = 0.0170012651637401115072940643790
        D[7,3] = -0.0308768122087187668642407450884
        D[7,4] = -0.00100830698169458999033769627753
        D[7,5] = 0.180276184279075439915490736124
        D[7,6] = -0.795651759147225902829035655216
        D[7,8] = 0.799910633993996260447079117130
        D[7,9] = -0.199977658498499065111769779282
        D[7,10] = 0.0380909825711426790689085293871
        D[7,11] = -0.00357102961604462616271017463004
        
        #bottom portion of the matrices
        for i in range(8):
            for j in range(12):
                D[-1-i,-1-j] = -D[i,j]
                if i == j:
                    H[-1-i,-1-i] = H[i,j]

        x = np.linspace(0, nn-1, nn, endpoint=True, dtype=np.float64)
        x[1] = 0.4201521473 / 0.6476381109
        x[2] = 0.3666429902 / 0.2010617441
        x[3] = 0.9061125799 / 0.3037910163
        x[-4] = nn - 1. - 0.9061125799 / 0.3037910163
        x[-3] = nn - 1. - 0.3666429902 / 0.2010617441
        x[-2] = nn - 1. - 0.4201521473 / 0.6476381109
        x = x / (nn-1)
        
    else:
        print("ERROR: You have not coded this order p yet")
        sys.exit()

    Q = H@D
    D = D / dx 
    H = H * dx
    S = Q - E/2
    
    return H, D, Q, E, S, dx, x

def HGTOp(p,nn):
    """ Builds a 1D HGT first derivative operator on reference element [0,1] 
    for p=2,3,4
    INPUT: derivative order, grid size
    OUTPUT: 2D arrays (matrix) H and D """ 
    
    dx = 1/(nn-1)
    H = np.diag(np.ones(nn))
    tR = np.zeros(nn)
    tL = np.zeros(nn)

    if p==2:
        if nn < 9:
            print ( '' )
            print ( 'HGT_SET - Fatal error!' )
            print ( '  Illegal value of nn: %d' % ( nn ) )
            print ( '  nn must be at least 9 when p=2' )
            sys.exit ( 'HGT_SET - Fatal error!' )
                
        H[0,0] = 0.5626503937015199
        H[1,1] = 0.92436013078123
        H[2,2] = 1.0190360469826
        H[3,3] = 0.9939534285346701
                    
        D = pentadiag(nn, 1/12, -2/3, 0, 2/3, -1/12)
        D[0,0] = -2.174199764799834
        D[0,1] = 3.145750470689077
        D[0,2] = -1.214022436120709
        D[0,3] = 0.2424717302314663
        D[1,0] = -0.4398787083635645
        D[1,1] = -0.4109380435663456
        D[1,2] = 1.037087099747049
        D[1,3] = -0.1862703478171391
        D[2,0] = 0.07162334465472171
        D[2,1] = -0.6071238279682888
        D[2,2] = -0.07464330351364873
        D[2,3] = 0.6919204163979632
        D[2,4] = -0.08177662957074722
        D[3,0] = -0.007280390946012310
        D[3,1] = 0.1008007196831248
        D[3,2] = -0.6769706855298218
        D[3,3] = -0.003431600235507266
        D[3,4] = 0.6707222366036759
        D[3,5] = -0.08384027957545949

        tL[0] = 1.564170293574442
        tL[1] = -0.8716131523720464
        tL[2] = 0.3900364520048603
        tL[3] = -0.08259359320725589
        
        #bottom portion of the matrices
        for i in range(4):
            for j in range(6):
                D[-1-i,-1-j] = -D[i,j]
                if i == j:
                    H[-1-i,-1-i] = H[i,j]
                    tR[-1-i] = tL[i]

        x = np.linspace(0, nn-1, nn, endpoint=True, dtype=np.float64)
        x[0] = 0.2245784979812614
        x[1] = 1.013719374359164
        x[-2] = nn - 2.013719374359164
        x[-1] = nn - 1.224578497981261
        x = x / (nn-1)
  
    elif p==3:
        if nn < 13:
                print ( '' )
                print ( 'HGT_SET - Fatal error!' )
                print ( '  Illegal value of nn: %d' % ( nn ) )
                print ( '  nn must be at least 13 when p=3' )
                sys.exit ( 'HGT_SET - Fatal error!' )
                
        H[0,0] = 0.5414201447307199
        H[1,1] = 0.9493700968218414
        H[2,2] = 1.011540202023541
        H[3,3] = 0.9961556602732164
        H[4,4] = 1.001887133878803
        H[5,5] = 0.9996267622718789

        D = heptadiag(nn,-1/60,3/20,-3/4,0,3/4,-3/20,1/60)
        D[0,0] = -2.704961750355033
        D[0,1] = 4.907594894493701
        D[0,2] = -3.891011093934747
        D[0,3] = 2.449061068475661
        D[0,4] = -0.9052732401762248
        D[0,5] = 0.1445901214966439
        D[1,0] = -0.2797841748290440
        D[1,1] = -1.028329421235741
        D[1,2] = 2.114939062416877
        D[1,3] = -1.160753668439965
        D[1,4] = 0.4215882374434574
        D[1,5] = -0.06766003535558369
        D[2,0] = 0.008705624977652661
        D[2,1] = -0.2916657688116944
        D[2,2] = -0.7427055796193680
        D[2,3] = 1.400259276088679
        D[2,4] = -0.4459163214035907
        D[2,5] = 0.07132276876832123
        D[3,0] = 0.01305512960279307
        D[3,1] = 0.008795261190797448
        D[3,2] = -0.4591698140920839
        D[3,3] = -0.3072294255679415
        D[3,4] = 0.9122106551220590
        D[3,5] = -0.1843927925174454
        D[3,6] = 0.01673098626182126
        D[4,0] = -0.002825253712880857
        D[4,1] = 0.002238829042572789
        D[4,2] = 0.09780258253377587
        D[4,3] = -0.6820642406555288
        D[4,4] = -0.04140527245917604
        D[4,5] = 0.7593355446762412
        D[4,6] = -0.1497174631031297
        D[4,7] = 0.01663527367812552
        D[5,0] = -0.0002853325693438575
        D[5,1] = 0.0005515582427172874
        D[5,2] = -0.01628690807240203
        D[5,3] = 0.1480829955793182
        D[5,4] = -0.7479203088339520
        D[5,5] = -0.001038920216368430
        D[5,6] = 0.7502800328149024
        D[5,7] = -0.1500560065629805
        D[5,8] = 0.01667288961810895

        tL[0] = 1.711444292034236
        tL[1] = -1.397329740757939
        tL[2] = 1.225786728637724
        tL[3] = -0.7823660668536100
        tL[4] = 0.2880396144685478
        tL[5] = -0.04557482752895886
        
        #bottom portion of the matrices
        for i in range(6):
            for j in range(9):
                D[-1-i,-1-j] = -D[i,j]
                if i == j:
                    H[-1-i,-1-i] = H[i,j]
                    tR[-1-i] = tL[i]

        x = np.linspace(0, nn-1, nn, endpoint=True, dtype=np.float64)
        x[0] = 0.2180540672543505
        x[1] = 1.001181873031216
        x[2] = 1.997580526418033
        x[-3] = nn - 2.997580526418033
        x[-2] = nn - 2.001181873031216
        x[-1] = nn - 1.218054067254351
        x = x / (nn-1)
        
    elif p==4:
        if nn < 17:
            print ( '' )
            print ( 'HGT_SET - Fatal error!' )
            print ( '  Illegal value of nn: %d' % ( nn ) )
            print ( '  nn must be at least 17 when p=4' )
            sys.exit ( 'HGT_SET - Fatal error!' )
                
        H[0,0] = 0.4935469023930283
        H[1,1] = 0.9426144059546099
        H[2,2] = 1.054085066573855
        H[3,3] = 1.009295442598466
        H[4,4] = 1.000802807287322
        H[5,5] = 0.9995176179148104
        H[6,6] = 1.000160690664882
        H[7,7] = 0.9999770666130262

        D = nonadiag(nn,1/280,-4/105,1/5,-4/5,0,4/5,-1/5,4/105,-1/280)
        D[0,0] = -3.106044667960493
        D[0,1] = 6.180526454135114
        D[0,2] = -6.762331518443771
        D[0,3] = 6.961173256217043
        D[0,4] = -5.037107432688628
        D[0,5] = 2.284935300812669
        D[0,6] = -0.5853135234394218
        D[0,7] = 0.06416213136748800
        D[1,0] = -0.2020193613086322
        D[1,1] = -1.415101852772709
        D[1,2] = 3.108515083761492
        D[1,3] = -2.574424810471354
        D[1,4] = 1.474227647118206
        D[1,5] = -0.4157792256851002
        D[1,6] = 0.009631954823440826
        D[1,7] = 0.01495056453465650
        D[2,0] = -0.1410865905931143
        D[2,1] = 0.3053552055355819
        D[2,2] = -1.880373143757474
        D[2,3] = 2.591426945634568
        D[2,4] = -0.9159049976630367
        D[2,5] = -0.1526372859169159
        D[2,6] = 0.2579971500022937
        D[2,7] = -0.06477728324190289
        D[3,0] = 0.2973278819350951
        D[3,1] = -1.048314216074811
        D[3,2] = 1.502313145596027
        D[3,3] = -2.254980793108914
        D[3,4] = 1.597285443250220
        D[3,5] = 0.1886096413538605
        D[3,6] = -0.3792396959708519
        D[3,7] = 0.09699859301937505
        D[4,0] = -0.3333481874795271
        D[4,1] = 1.239585697758120
        D[4,2] = -2.238950617669327
        D[4,3] = 1.822062615156636
        D[4,4] = -1.295538314838973
        D[4,5] = 0.7711649692542688
        D[4,6] = 0.07876535118068832
        D[4,7] = -0.04017294965940313
        D[4,8] = -0.003568563702482944
        D[5,0] = 0.2277865716277502
        D[5,1] = -0.8728306141197878
        D[5,2] = 1.702914441471244
        D[5,3] = -1.842756468011544
        D[5,4] = 0.4749632466942140
        D[5,5] = -0.2997422933116026
        D[5,6] = 0.7454721566802552
        D[5,7] = -0.1703475122588727
        D[5,8] = 0.03811362342437968
        D[5,9] = -0.003573152196035595
        D[6,0] = -0.08736410095433229
        D[6,1] = 0.3418426033695625
        D[6,2] = -0.6996745034875126
        D[6,3] = 0.8410861488032502
        D[6,4] = -0.4247927958726105
        D[6,5] = -0.5786833918759315
        D[6,6] = -0.02308368611029528
        D[6,7] = 0.7961193303971456
        D[6,8] = -0.1999678670304918
        D[6,9] = 0.03808911752961748
        D[6,10] = -0.003570854768401638
        D[7,0] = 0.01436069216029530
        D[7,1] = -0.05702869278844157
        D[7,2] = 0.1206204432261557
        D[7,3] = -0.1539864556601782
        D[7,4] = 0.08253703011996900
        D[7,5] = 0.1499209774985774
        D[7,6] = -0.7906168574876657
        D[7,7] = -0.0003454987063186220
        D[7,8] = 0.8000183471303409
        D[7,9] = -0.2000045867825852
        D[7,10] = 0.03809611176811148
        D[7,11] = -0.003571510478260450

        tL[0] = 1.750987563957142
        tL[1] = -1.633337315018925
        tL[2] = 1.991016449164238
        tL[3] = -2.133514395372997
        tL[4] = 1.610328154407748
        tL[5] = -0.7740771318145698
        tL[6] = 0.2148832028948018
        tL[7] = -0.02628652821743834
        
        #bottom portion of the matrices
        for i in range(8):
            for j in range(12):
                D[-1-i,-1-j] = -D[i,j]
                if i == j:
                    H[-1-i,-1-i] = H[i,j]
                    tR[-1-i] = tL[i]

        x = np.linspace(0, nn-1, nn, endpoint=True, dtype=np.float64)
        x[0] = 0.1967602438183433
        x[1] = 0.9418350019929199
        x[2] = 1.965203367854091
        x[3] = 2.997478343847042
        x[-4] = nn - 3.997478343847042
        x[-3] = nn - 2.965203367854091
        x[-2] = nn - 1.941835001992920
        x[-1] = nn - 1.196760243818343
        x = x / (nn-1)
        
    else:
        print("ERROR: You have not coded this order p yet")
        sys.exit()

    E = np.outer(tR,tR) - np.outer(tL,tL)
    Q = H@D
    D = D / dx 
    H = H * dx
    S = Q - E/2
    
    return H, D, Q, E, S, dx, x, tL, tR

def MattOp(p,nn):
    """ Builds a 1D Mattsson Optimized 'Accurate' first derivative operator on reference element [0,1]
    from 'Boundary optimized diagonal-norm SBP operators' Mattsson, Almquist, van der Weide 2018
    for p=2,3
    INPUT: derivative order, grid size
    OUTPUT: 2D arrays (matrix) H and D """ 
    
    E = np.zeros((nn,nn))
    E[0,0] = -1
    E[-1,-1] = 1

    if p==2:
        if nn < 9:
            print ( '' )
            print ( 'MATTSSON_SET - Fatal error!' )
            print ( '  Illegal value of nn: %d' % ( nn ) )
            print ( '  nn must be at least 9 when p=2' )
            sys.exit ( 'MATTSSON_SET - Fatal error!' )
                
        H = np.diag(np.ones(nn))
        H[0,0] = 0.21259737557798
        H[1,1] = 1.0260290400758
        H[2,2] = 1.0775123588954
        H[3,3] = 0.98607273802835
                    
        D = pentadiag(nn, 1/12, -2/3, 0, 2/3, -1/12)
        D[0,0] = -2.351863463227944
        D[0,1] = 3.085893212909357
        D[0,2] = -0.9349061508864489
        D[0,3] = 0.2008764012050358
        D[1,0] = -0.6394095807755722
        D[1,2] = 0.7917608885016884
        D[1,3] = -0.1523513077261164
        D[2,0] = 0.1844606165760597
        D[2,1] = -0.7539307161467195
        D[2,3] = 0.6468087329936288
        D[2,4] = -0.07733863342297213
        D[3,0] = -0.04330897109794368
        D[3,1] = 0.1585246807786971
        D[3,2] = -0.7067880256335334
        D[3,4] = 0.6760826468031810
        D[3,5] = -0.08451033085039762
        
        #bottom portion of the matrices
        for i in range(4):
            for j in range(6):
                D[-1-i,-1-j] = -D[i,j]
                if i == j:
                    H[-1-i,-1-i] = H[i,j]

        dx1 = 0.68764546205559
        dx2 = 1.114566050522
        dxp = dx1 + dx2
        h = 1.0 / (2.0 * dxp + nn - 2.0 * 2.0 - 1.0)

        x = np.zeros(nn)
        x[:3] = [0.0, dx1 * h, dxp * h]
        j = np.arange(4, nn - 2)
        x[3:nn - 3] = (dxp + j - 3.0) * h
        x[nn - 3:] = [1.0 - dxp * h, 1.0 - dx1 * h, 1.0]
  
    elif p==3:
        if nn < 13:
                print ( '' )
                print ( 'MATTSSON_SET - Fatal error!' )
                print ( '  Illegal value of nn: %d' % ( nn ) )
                print ( '  nn must be at least 13 when p=3' )
                sys.exit ( 'MATTSSON_SET - Fatal error!' )
                
        H = np.diag(np.ones(nn))
        H[0,0] = 0.13030223027124
        H[1,1] = 0.6885150158771499
        H[2,2] = 0.95166202564389
        H[3,3] = 0.99103890475697
        H[4,4] = 1.0028757074552
        H[5,5] = 0.99950151111941

        D = heptadiag(nn,-1/60,3/20,-3/4,0,3/4,-3/20,1/60)
        D[0,0] = -3.8372328620868
        D[0,1] = 5.068376175016301
        D[0,2] = -1.6963756420892
        D[0,3] = 0.58512950738742
        D[0,4] = -0.13275449453717
        D[0,5] = 0.012857316309426
        D[1,0] = -0.95919581160751
        D[1,2] = 1.2687130518352
        D[1,3] = -0.38607319579254
        D[1,4] = 0.083452769545067
        D[1,5] = -0.006896813980236099
        D[2,0] = 0.23226893958753
        D[2,1] = -0.91789728232231
        D[2,3] = 0.8585728949642
        D[2,4] = -0.19840158580452
        D[2,5] = 0.025457033575096
        D[3,0] = -0.076933084507707
        D[3,1] = 0.26822074416546
        D[3,2] = -0.8244592785032399
        D[3,4] = 0.7749305933808099
        D[3,5] = -0.15857634324474
        D[3,6] = 0.016817368709409
        D[4,0] = 0.01724860477538
        D[4,1] = -0.05729372495632099
        D[4,2] = 0.18826984603785
        D[4,3] = -0.76578419520756
        D[4,5] = 0.75051047448733
        D[4,6] = -0.14956988077877
        D[4,7] = 0.016618875642086
        D[5,0] = -0.001676172543796
        D[5,1] = 0.004750928272020101
        D[5,2] = -0.024238574798979
        D[5,3] = 0.15723370478312
        D[5,4] = -0.75304410716804
        D[5,6] = 0.75037405312176
        D[5,7] = -0.15007481062435
        D[5,8] = 0.016674978958261
        
        #bottom portion of the matrices
        for i in range(6):
            for j in range(9):
                D[-1-i,-1-j] = -D[i,j]
                if i == j:
                    H[-1-i,-1-i] = H[i,j]

        dx1 = 0.44090263368623
        dx2 = 0.84469580082107
        dx3 = 0.9782969606166001
        dxp = dx1 + dx2 + dx3
        h = 1.0 / (2.0 * dxp + nn - 2.0 * 3.0 - 1.0)

        x = np.zeros(nn)
        x[:4] = [0.0, dx1 * h, (dx1 + dx2) * h, dxp * h]
        j = np.arange(5, nn - 3)
        x[4:nn - 4] = (dxp + j - 4.0) * h
        x[nn - 4:] = [1.0 - dxp * h, 1.0 - (dx1 + dx2) * h, 1.0 - dx1 * h, 1.0]
        
    else:
        print("ERROR: You have not coded this order p yet")
        sys.exit()

    Q = H@D
    D = D / h
    H = H * h
    S = Q - E/2
    
    return H, D, Q, E, S, h, x
        
        
        
        